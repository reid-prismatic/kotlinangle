/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/JavaEmitter.java on Mon Aug 26 09:27:49 KST 2024 ----! */
/* !---- C-Unit: AngleNative_JNI.c, output/gensrc/native/AngleNative_JNI.c ----! */

#include <jni.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <stddef.h>

JavaVM* JVMUtil_GetJavaVM();
JNIEnv* JVMUtil_GetJNIEnv(int asDaemon, int* jvmAttached);
void JVMUtil_ReleaseJNIEnv(JNIEnv* env, int detachJVM);


static jobject JVMUtil_NewDirectByteBufferCopy(JNIEnv *env, jclass clazzBuffers, void * source_address, size_t capacity); /* forward decl. */

 #include <GLES2/gl2.h>

/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glActiveTexture(int texture)
 *     C function: void glActiveTexture(GLenum texture)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glActiveTexture__I(JNIEnv *env, jclass _unused, jint texture) {
  glActiveTexture((GLenum) texture);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glAttachShader(int program, int shader)
 *     C function: void glAttachShader(GLuint program, GLuint shader)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glAttachShader__II(JNIEnv *env, jclass _unused, jint program, jint shader) {
  glAttachShader((GLuint) program, (GLuint) shader);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glBindAttribLocation(int program, int index, java.nio.ByteBuffer name)
 *     C function: void glBindAttribLocation(GLuint program, GLuint index, const GLchar *  name)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glBindAttribLocation1__IILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint program, jint index, jobject name, jint name_byte_offset, jboolean name_is_nio) {
  GLchar * _name_ptr = NULL;
  if ( NULL != name ) {
    _name_ptr = (GLchar *) ( JNI_TRUE == name_is_nio ?  (*env)->GetDirectBufferAddress(env, name) :  (*env)->GetPrimitiveArrayCritical(env, name, NULL) );  }
  glBindAttribLocation((GLuint) program, (GLuint) index, (const GLchar * ) (((char *) _name_ptr) + name_byte_offset));
  if ( JNI_FALSE == name_is_nio && NULL != name ) {
    (*env)->ReleasePrimitiveArrayCritical(env, name, _name_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glBindBuffer(int target, int buffer)
 *     C function: void glBindBuffer(GLenum target, GLuint buffer)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glBindBuffer__II(JNIEnv *env, jclass _unused, jint target, jint buffer) {
  glBindBuffer((GLenum) target, (GLuint) buffer);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glBindFramebuffer(int target, int framebuffer)
 *     C function: void glBindFramebuffer(GLenum target, GLuint framebuffer)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glBindFramebuffer__II(JNIEnv *env, jclass _unused, jint target, jint framebuffer) {
  glBindFramebuffer((GLenum) target, (GLuint) framebuffer);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glBindRenderbuffer(int target, int renderbuffer)
 *     C function: void glBindRenderbuffer(GLenum target, GLuint renderbuffer)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glBindRenderbuffer__II(JNIEnv *env, jclass _unused, jint target, jint renderbuffer) {
  glBindRenderbuffer((GLenum) target, (GLuint) renderbuffer);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glBindTexture(int target, int texture)
 *     C function: void glBindTexture(GLenum target, GLuint texture)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glBindTexture__II(JNIEnv *env, jclass _unused, jint target, jint texture) {
  glBindTexture((GLenum) target, (GLuint) texture);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glBlendColor(float red, float green, float blue, float alpha)
 *     C function: void glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glBlendColor__FFFF(JNIEnv *env, jclass _unused, jfloat red, jfloat green, jfloat blue, jfloat alpha) {
  glBlendColor((GLfloat) red, (GLfloat) green, (GLfloat) blue, (GLfloat) alpha);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glBlendEquation(int mode)
 *     C function: void glBlendEquation(GLenum mode)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glBlendEquation__I(JNIEnv *env, jclass _unused, jint mode) {
  glBlendEquation((GLenum) mode);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glBlendEquationSeparate(int modeRGB, int modeAlpha)
 *     C function: void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glBlendEquationSeparate__II(JNIEnv *env, jclass _unused, jint modeRGB, jint modeAlpha) {
  glBlendEquationSeparate((GLenum) modeRGB, (GLenum) modeAlpha);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glBlendFunc(int sfactor, int dfactor)
 *     C function: void glBlendFunc(GLenum sfactor, GLenum dfactor)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glBlendFunc__II(JNIEnv *env, jclass _unused, jint sfactor, jint dfactor) {
  glBlendFunc((GLenum) sfactor, (GLenum) dfactor);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glBlendFuncSeparate(int sfactorRGB, int dfactorRGB, int sfactorAlpha, int dfactorAlpha)
 *     C function: void glBlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glBlendFuncSeparate__IIII(JNIEnv *env, jclass _unused, jint sfactorRGB, jint dfactorRGB, jint sfactorAlpha, jint dfactorAlpha) {
  glBlendFuncSeparate((GLenum) sfactorRGB, (GLenum) dfactorRGB, (GLenum) sfactorAlpha, (GLenum) dfactorAlpha);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glBufferData(int target, int size, java.nio.Buffer data, int usage)
 *     C function: void glBufferData(GLenum target, GLsizeiptr size, const void *  data, GLenum usage)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glBufferData1__IILjava_lang_Object_2IZI(JNIEnv *env, jclass _unused, jint target, jint size, jobject data, jint data_byte_offset, jboolean data_is_nio, jint usage) {
  void * _data_ptr = NULL;
  if ( NULL != data ) {
    _data_ptr = (void *) ( JNI_TRUE == data_is_nio ?  (*env)->GetDirectBufferAddress(env, data) :  (*env)->GetPrimitiveArrayCritical(env, data, NULL) );  }
  glBufferData((GLenum) target, (GLsizeiptr) size, (const void * ) (((char *) _data_ptr) + data_byte_offset), (GLenum) usage);
  if ( JNI_FALSE == data_is_nio && NULL != data ) {
    (*env)->ReleasePrimitiveArrayCritical(env, data, _data_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glBufferSubData(int target, int offset, int size, java.nio.Buffer data)
 *     C function: void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void *  data)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glBufferSubData1__IIILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint target, jint offset, jint size, jobject data, jint data_byte_offset, jboolean data_is_nio) {
  void * _data_ptr = NULL;
  if ( NULL != data ) {
    _data_ptr = (void *) ( JNI_TRUE == data_is_nio ?  (*env)->GetDirectBufferAddress(env, data) :  (*env)->GetPrimitiveArrayCritical(env, data, NULL) );  }
  glBufferSubData((GLenum) target, (GLintptr) offset, (GLsizeiptr) size, (const void * ) (((char *) _data_ptr) + data_byte_offset));
  if ( JNI_FALSE == data_is_nio && NULL != data ) {
    (*env)->ReleasePrimitiveArrayCritical(env, data, _data_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: int glCheckFramebufferStatus(int target)
 *     C function: GLenum glCheckFramebufferStatus(GLenum target)
 */
JNIEXPORT jint JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glCheckFramebufferStatus__I(JNIEnv *env, jclass _unused, jint target) {
  GLenum _res;
  _res = (GLenum) glCheckFramebufferStatus((GLenum) target);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glClear(int mask)
 *     C function: void glClear(GLbitfield mask)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glClear__I(JNIEnv *env, jclass _unused, jint mask) {
  glClear((GLbitfield) mask);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glClearColor(float red, float green, float blue, float alpha)
 *     C function: void glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
 */
JNIEXPORT jint JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glClearColor__FFFF(JNIEnv *env, jclass _unused, jfloat red, jfloat green, jfloat blue, jfloat alpha) {
  glClearColor((GLfloat) red, (GLfloat) green, (GLfloat) blue, (GLfloat) alpha);
  return 33;
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glClearDepthf(float d)
 *     C function: void glClearDepthf(GLfloat d)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glClearDepthf__F(JNIEnv *env, jclass _unused, jfloat d) {
  glClearDepthf((GLfloat) d);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glClearStencil(int s)
 *     C function: void glClearStencil(GLint s)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glClearStencil__I(JNIEnv *env, jclass _unused, jint s) {
  glClearStencil((GLint) s);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glColorMask(byte red, byte green, byte blue, byte alpha)
 *     C function: void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glColorMask__BBBB(JNIEnv *env, jclass _unused, jbyte red, jbyte green, jbyte blue, jbyte alpha) {
  glColorMask((GLboolean) red, (GLboolean) green, (GLboolean) blue, (GLboolean) alpha);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glCompileShader(int shader)
 *     C function: void glCompileShader(GLuint shader)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glCompileShader__I(JNIEnv *env, jclass _unused, jint shader) {
  glCompileShader((GLuint) shader);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, java.nio.Buffer data)
 *     C function: void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *  data)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glCompressedTexImage2D1__IIIIIIILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint target, jint level, jint internalformat, jint width, jint height, jint border, jint imageSize, jobject data, jint data_byte_offset, jboolean data_is_nio) {
  void * _data_ptr = NULL;
  if ( NULL != data ) {
    _data_ptr = (void *) ( JNI_TRUE == data_is_nio ?  (*env)->GetDirectBufferAddress(env, data) :  (*env)->GetPrimitiveArrayCritical(env, data, NULL) );  }
  glCompressedTexImage2D((GLenum) target, (GLint) level, (GLenum) internalformat, (GLsizei) width, (GLsizei) height, (GLint) border, (GLsizei) imageSize, (const void * ) (((char *) _data_ptr) + data_byte_offset));
  if ( JNI_FALSE == data_is_nio && NULL != data ) {
    (*env)->ReleasePrimitiveArrayCritical(env, data, _data_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glCompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, java.nio.Buffer data)
 *     C function: void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *  data)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glCompressedTexSubImage2D1__IIIIIIIILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint target, jint level, jint xoffset, jint yoffset, jint width, jint height, jint format, jint imageSize, jobject data, jint data_byte_offset, jboolean data_is_nio) {
  void * _data_ptr = NULL;
  if ( NULL != data ) {
    _data_ptr = (void *) ( JNI_TRUE == data_is_nio ?  (*env)->GetDirectBufferAddress(env, data) :  (*env)->GetPrimitiveArrayCritical(env, data, NULL) );  }
  glCompressedTexSubImage2D((GLenum) target, (GLint) level, (GLint) xoffset, (GLint) yoffset, (GLsizei) width, (GLsizei) height, (GLenum) format, (GLsizei) imageSize, (const void * ) (((char *) _data_ptr) + data_byte_offset));
  if ( JNI_FALSE == data_is_nio && NULL != data ) {
    (*env)->ReleasePrimitiveArrayCritical(env, data, _data_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glCopyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border)
 *     C function: void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glCopyTexImage2D__IIIIIIII(JNIEnv *env, jclass _unused, jint target, jint level, jint internalformat, jint x, jint y, jint width, jint height, jint border) {
  glCopyTexImage2D((GLenum) target, (GLint) level, (GLenum) internalformat, (GLint) x, (GLint) y, (GLsizei) width, (GLsizei) height, (GLint) border);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glCopyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
 *     C function: void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glCopyTexSubImage2D__IIIIIIII(JNIEnv *env, jclass _unused, jint target, jint level, jint xoffset, jint yoffset, jint x, jint y, jint width, jint height) {
  glCopyTexSubImage2D((GLenum) target, (GLint) level, (GLint) xoffset, (GLint) yoffset, (GLint) x, (GLint) y, (GLsizei) width, (GLsizei) height);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: int glCreateProgram()
 *     C function: GLuint glCreateProgram()
 */
JNIEXPORT jint JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glCreateProgram__(JNIEnv *env, jclass _unused) {
  GLuint _res;
  _res = (GLuint) glCreateProgram();
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: int glCreateShader(int type)
 *     C function: GLuint glCreateShader(GLenum type)
 */
JNIEXPORT jint JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glCreateShader__I(JNIEnv *env, jclass _unused, jint type) {
  GLuint _res;
  _res = (GLuint) glCreateShader((GLenum) type);
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glCullFace(int mode)
 *     C function: void glCullFace(GLenum mode)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glCullFace__I(JNIEnv *env, jclass _unused, jint mode) {
  glCullFace((GLenum) mode);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glDeleteBuffers(int n, java.nio.IntBuffer buffers)
 *     C function: void glDeleteBuffers(GLsizei n, const GLuint *  buffers)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glDeleteBuffers1__ILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint n, jobject buffers, jint buffers_byte_offset, jboolean buffers_is_nio) {
  GLuint * _buffers_ptr = NULL;
  if ( NULL != buffers ) {
    _buffers_ptr = (GLuint *) ( JNI_TRUE == buffers_is_nio ?  (*env)->GetDirectBufferAddress(env, buffers) :  (*env)->GetPrimitiveArrayCritical(env, buffers, NULL) );  }
  glDeleteBuffers((GLsizei) n, (const GLuint * ) (((char *) _buffers_ptr) + buffers_byte_offset));
  if ( JNI_FALSE == buffers_is_nio && NULL != buffers ) {
    (*env)->ReleasePrimitiveArrayCritical(env, buffers, _buffers_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glDeleteFramebuffers(int n, java.nio.IntBuffer framebuffers)
 *     C function: void glDeleteFramebuffers(GLsizei n, const GLuint *  framebuffers)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glDeleteFramebuffers1__ILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint n, jobject framebuffers, jint framebuffers_byte_offset, jboolean framebuffers_is_nio) {
  GLuint * _framebuffers_ptr = NULL;
  if ( NULL != framebuffers ) {
    _framebuffers_ptr = (GLuint *) ( JNI_TRUE == framebuffers_is_nio ?  (*env)->GetDirectBufferAddress(env, framebuffers) :  (*env)->GetPrimitiveArrayCritical(env, framebuffers, NULL) );  }
  glDeleteFramebuffers((GLsizei) n, (const GLuint * ) (((char *) _framebuffers_ptr) + framebuffers_byte_offset));
  if ( JNI_FALSE == framebuffers_is_nio && NULL != framebuffers ) {
    (*env)->ReleasePrimitiveArrayCritical(env, framebuffers, _framebuffers_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glDeleteProgram(int program)
 *     C function: void glDeleteProgram(GLuint program)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glDeleteProgram__I(JNIEnv *env, jclass _unused, jint program) {
  glDeleteProgram((GLuint) program);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glDeleteRenderbuffers(int n, java.nio.IntBuffer renderbuffers)
 *     C function: void glDeleteRenderbuffers(GLsizei n, const GLuint *  renderbuffers)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glDeleteRenderbuffers1__ILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint n, jobject renderbuffers, jint renderbuffers_byte_offset, jboolean renderbuffers_is_nio) {
  GLuint * _renderbuffers_ptr = NULL;
  if ( NULL != renderbuffers ) {
    _renderbuffers_ptr = (GLuint *) ( JNI_TRUE == renderbuffers_is_nio ?  (*env)->GetDirectBufferAddress(env, renderbuffers) :  (*env)->GetPrimitiveArrayCritical(env, renderbuffers, NULL) );  }
  glDeleteRenderbuffers((GLsizei) n, (const GLuint * ) (((char *) _renderbuffers_ptr) + renderbuffers_byte_offset));
  if ( JNI_FALSE == renderbuffers_is_nio && NULL != renderbuffers ) {
    (*env)->ReleasePrimitiveArrayCritical(env, renderbuffers, _renderbuffers_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glDeleteShader(int shader)
 *     C function: void glDeleteShader(GLuint shader)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glDeleteShader__I(JNIEnv *env, jclass _unused, jint shader) {
  glDeleteShader((GLuint) shader);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glDeleteTextures(int n, java.nio.IntBuffer textures)
 *     C function: void glDeleteTextures(GLsizei n, const GLuint *  textures)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glDeleteTextures1__ILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint n, jobject textures, jint textures_byte_offset, jboolean textures_is_nio) {
  GLuint * _textures_ptr = NULL;
  if ( NULL != textures ) {
    _textures_ptr = (GLuint *) ( JNI_TRUE == textures_is_nio ?  (*env)->GetDirectBufferAddress(env, textures) :  (*env)->GetPrimitiveArrayCritical(env, textures, NULL) );  }
  glDeleteTextures((GLsizei) n, (const GLuint * ) (((char *) _textures_ptr) + textures_byte_offset));
  if ( JNI_FALSE == textures_is_nio && NULL != textures ) {
    (*env)->ReleasePrimitiveArrayCritical(env, textures, _textures_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glDepthFunc(int func)
 *     C function: void glDepthFunc(GLenum func)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glDepthFunc__I(JNIEnv *env, jclass _unused, jint func) {
  glDepthFunc((GLenum) func);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glDepthMask(byte flag)
 *     C function: void glDepthMask(GLboolean flag)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glDepthMask__B(JNIEnv *env, jclass _unused, jbyte flag) {
  glDepthMask((GLboolean) flag);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glDepthRangef(float n, float f)
 *     C function: void glDepthRangef(GLfloat n, GLfloat f)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glDepthRangef__FF(JNIEnv *env, jclass _unused, jfloat n, jfloat f) {
  glDepthRangef((GLfloat) n, (GLfloat) f);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glDetachShader(int program, int shader)
 *     C function: void glDetachShader(GLuint program, GLuint shader)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glDetachShader__II(JNIEnv *env, jclass _unused, jint program, jint shader) {
  glDetachShader((GLuint) program, (GLuint) shader);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glDisable(int cap)
 *     C function: void glDisable(GLenum cap)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glDisable__I(JNIEnv *env, jclass _unused, jint cap) {
  glDisable((GLenum) cap);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glDisableVertexAttribArray(int index)
 *     C function: void glDisableVertexAttribArray(GLuint index)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glDisableVertexAttribArray__I(JNIEnv *env, jclass _unused, jint index) {
  glDisableVertexAttribArray((GLuint) index);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glDrawArrays(int mode, int first, int count)
 *     C function: void glDrawArrays(GLenum mode, GLint first, GLsizei count)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glDrawArrays__III(JNIEnv *env, jclass _unused, jint mode, jint first, jint count) {
  glDrawArrays((GLenum) mode, (GLint) first, (GLsizei) count);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glDrawElements(int mode, int count, int type, java.nio.Buffer indices)
 *     C function: void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void *  indices)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glDrawElements1__IIILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint mode, jint count, jint type, jobject indices, jint indices_byte_offset, jboolean indices_is_nio) {
  void * _indices_ptr = NULL;
  if ( NULL != indices ) {
    _indices_ptr = (void *) ( JNI_TRUE == indices_is_nio ?  (*env)->GetDirectBufferAddress(env, indices) :  (*env)->GetPrimitiveArrayCritical(env, indices, NULL) );  }
  glDrawElements((GLenum) mode, (GLsizei) count, (GLenum) type, (const void * ) (((char *) _indices_ptr) + indices_byte_offset));
  if ( JNI_FALSE == indices_is_nio && NULL != indices ) {
    (*env)->ReleasePrimitiveArrayCritical(env, indices, _indices_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glEnable(int cap)
 *     C function: void glEnable(GLenum cap)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glEnable__I(JNIEnv *env, jclass _unused, jint cap) {
  glEnable((GLenum) cap);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glEnableVertexAttribArray(int index)
 *     C function: void glEnableVertexAttribArray(GLuint index)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glEnableVertexAttribArray__I(JNIEnv *env, jclass _unused, jint index) {
  glEnableVertexAttribArray((GLuint) index);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glFinish()
 *     C function: void glFinish()
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glFinish__(JNIEnv *env, jclass _unused) {
  glFinish();
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glFlush()
 *     C function: void glFlush()
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glFlush__(JNIEnv *env, jclass _unused) {
  glFlush();
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glFramebufferRenderbuffer(int target, int attachment, int renderbuffertarget, int renderbuffer)
 *     C function: void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glFramebufferRenderbuffer__IIII(JNIEnv *env, jclass _unused, jint target, jint attachment, jint renderbuffertarget, jint renderbuffer) {
  glFramebufferRenderbuffer((GLenum) target, (GLenum) attachment, (GLenum) renderbuffertarget, (GLuint) renderbuffer);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glFramebufferTexture2D(int target, int attachment, int textarget, int texture, int level)
 *     C function: void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glFramebufferTexture2D__IIIII(JNIEnv *env, jclass _unused, jint target, jint attachment, jint textarget, jint texture, jint level) {
  glFramebufferTexture2D((GLenum) target, (GLenum) attachment, (GLenum) textarget, (GLuint) texture, (GLint) level);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glFrontFace(int mode)
 *     C function: void glFrontFace(GLenum mode)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glFrontFace__I(JNIEnv *env, jclass _unused, jint mode) {
  glFrontFace((GLenum) mode);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGenBuffers(int n, java.nio.IntBuffer buffers)
 *     C function: void glGenBuffers(GLsizei n, GLuint *  buffers)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGenBuffers1__ILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint n, jobject buffers, jint buffers_byte_offset, jboolean buffers_is_nio) {
  GLuint * _buffers_ptr = NULL;
  if ( NULL != buffers ) {
    _buffers_ptr = (GLuint *) ( JNI_TRUE == buffers_is_nio ?  (*env)->GetDirectBufferAddress(env, buffers) :  (*env)->GetPrimitiveArrayCritical(env, buffers, NULL) );  }
  glGenBuffers((GLsizei) n, (GLuint * ) (((char *) _buffers_ptr) + buffers_byte_offset));
  if ( JNI_FALSE == buffers_is_nio && NULL != buffers ) {
    (*env)->ReleasePrimitiveArrayCritical(env, buffers, _buffers_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGenerateMipmap(int target)
 *     C function: void glGenerateMipmap(GLenum target)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGenerateMipmap__I(JNIEnv *env, jclass _unused, jint target) {
  glGenerateMipmap((GLenum) target);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGenFramebuffers(int n, java.nio.IntBuffer framebuffers)
 *     C function: void glGenFramebuffers(GLsizei n, GLuint *  framebuffers)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGenFramebuffers1__ILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint n, jobject framebuffers, jint framebuffers_byte_offset, jboolean framebuffers_is_nio) {
  GLuint * _framebuffers_ptr = NULL;
  if ( NULL != framebuffers ) {
    _framebuffers_ptr = (GLuint *) ( JNI_TRUE == framebuffers_is_nio ?  (*env)->GetDirectBufferAddress(env, framebuffers) :  (*env)->GetPrimitiveArrayCritical(env, framebuffers, NULL) );  }
  glGenFramebuffers((GLsizei) n, (GLuint * ) (((char *) _framebuffers_ptr) + framebuffers_byte_offset));
  if ( JNI_FALSE == framebuffers_is_nio && NULL != framebuffers ) {
    (*env)->ReleasePrimitiveArrayCritical(env, framebuffers, _framebuffers_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGenRenderbuffers(int n, java.nio.IntBuffer renderbuffers)
 *     C function: void glGenRenderbuffers(GLsizei n, GLuint *  renderbuffers)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGenRenderbuffers1__ILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint n, jobject renderbuffers, jint renderbuffers_byte_offset, jboolean renderbuffers_is_nio) {
  GLuint * _renderbuffers_ptr = NULL;
  if ( NULL != renderbuffers ) {
    _renderbuffers_ptr = (GLuint *) ( JNI_TRUE == renderbuffers_is_nio ?  (*env)->GetDirectBufferAddress(env, renderbuffers) :  (*env)->GetPrimitiveArrayCritical(env, renderbuffers, NULL) );  }
  glGenRenderbuffers((GLsizei) n, (GLuint * ) (((char *) _renderbuffers_ptr) + renderbuffers_byte_offset));
  if ( JNI_FALSE == renderbuffers_is_nio && NULL != renderbuffers ) {
    (*env)->ReleasePrimitiveArrayCritical(env, renderbuffers, _renderbuffers_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGenTextures(int n, java.nio.IntBuffer textures)
 *     C function: void glGenTextures(GLsizei n, GLuint *  textures)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGenTextures1__ILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint n, jobject textures, jint textures_byte_offset, jboolean textures_is_nio) {
  GLuint * _textures_ptr = NULL;
  if ( NULL != textures ) {
    _textures_ptr = (GLuint *) ( JNI_TRUE == textures_is_nio ?  (*env)->GetDirectBufferAddress(env, textures) :  (*env)->GetPrimitiveArrayCritical(env, textures, NULL) );  }
  glGenTextures((GLsizei) n, (GLuint * ) (((char *) _textures_ptr) + textures_byte_offset));
  if ( JNI_FALSE == textures_is_nio && NULL != textures ) {
    (*env)->ReleasePrimitiveArrayCritical(env, textures, _textures_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGetActiveAttrib(int program, int index, int bufSize, java.nio.IntBuffer length, java.nio.IntBuffer size, java.nio.IntBuffer type, java.nio.ByteBuffer name)
 *     C function: void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetActiveAttrib1__IIILjava_lang_Object_2IZLjava_lang_Object_2IZLjava_lang_Object_2IZLjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint program, jint index, jint bufSize, jobject length, jint length_byte_offset, jboolean length_is_nio, jobject size, jint size_byte_offset, jboolean size_is_nio, jobject type, jint type_byte_offset, jboolean type_is_nio, jobject name, jint name_byte_offset, jboolean name_is_nio) {
  GLsizei * _length_ptr = NULL;
  GLint * _size_ptr = NULL;
  GLenum * _type_ptr = NULL;
  GLchar * _name_ptr = NULL;
  if ( NULL != length ) {
    _length_ptr = (GLsizei *) ( JNI_TRUE == length_is_nio ?  (*env)->GetDirectBufferAddress(env, length) :  (*env)->GetPrimitiveArrayCritical(env, length, NULL) );  }
  if ( NULL != size ) {
    _size_ptr = (GLint *) ( JNI_TRUE == size_is_nio ?  (*env)->GetDirectBufferAddress(env, size) :  (*env)->GetPrimitiveArrayCritical(env, size, NULL) );  }
  if ( NULL != type ) {
    _type_ptr = (GLenum *) ( JNI_TRUE == type_is_nio ?  (*env)->GetDirectBufferAddress(env, type) :  (*env)->GetPrimitiveArrayCritical(env, type, NULL) );  }
  if ( NULL != name ) {
    _name_ptr = (GLchar *) ( JNI_TRUE == name_is_nio ?  (*env)->GetDirectBufferAddress(env, name) :  (*env)->GetPrimitiveArrayCritical(env, name, NULL) );  }
  glGetActiveAttrib((GLuint) program, (GLuint) index, (GLsizei) bufSize, (GLsizei * ) (((char *) _length_ptr) + length_byte_offset), (GLint * ) (((char *) _size_ptr) + size_byte_offset), (GLenum * ) (((char *) _type_ptr) + type_byte_offset), (GLchar * ) (((char *) _name_ptr) + name_byte_offset));
  if ( JNI_FALSE == length_is_nio && NULL != length ) {
    (*env)->ReleasePrimitiveArrayCritical(env, length, _length_ptr, 0);  }
  if ( JNI_FALSE == size_is_nio && NULL != size ) {
    (*env)->ReleasePrimitiveArrayCritical(env, size, _size_ptr, 0);  }
  if ( JNI_FALSE == type_is_nio && NULL != type ) {
    (*env)->ReleasePrimitiveArrayCritical(env, type, _type_ptr, 0);  }
  if ( JNI_FALSE == name_is_nio && NULL != name ) {
    (*env)->ReleasePrimitiveArrayCritical(env, name, _name_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGetActiveUniform(int program, int index, int bufSize, java.nio.IntBuffer length, java.nio.IntBuffer size, java.nio.IntBuffer type, java.nio.ByteBuffer name)
 *     C function: void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetActiveUniform1__IIILjava_lang_Object_2IZLjava_lang_Object_2IZLjava_lang_Object_2IZLjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint program, jint index, jint bufSize, jobject length, jint length_byte_offset, jboolean length_is_nio, jobject size, jint size_byte_offset, jboolean size_is_nio, jobject type, jint type_byte_offset, jboolean type_is_nio, jobject name, jint name_byte_offset, jboolean name_is_nio) {
  GLsizei * _length_ptr = NULL;
  GLint * _size_ptr = NULL;
  GLenum * _type_ptr = NULL;
  GLchar * _name_ptr = NULL;
  if ( NULL != length ) {
    _length_ptr = (GLsizei *) ( JNI_TRUE == length_is_nio ?  (*env)->GetDirectBufferAddress(env, length) :  (*env)->GetPrimitiveArrayCritical(env, length, NULL) );  }
  if ( NULL != size ) {
    _size_ptr = (GLint *) ( JNI_TRUE == size_is_nio ?  (*env)->GetDirectBufferAddress(env, size) :  (*env)->GetPrimitiveArrayCritical(env, size, NULL) );  }
  if ( NULL != type ) {
    _type_ptr = (GLenum *) ( JNI_TRUE == type_is_nio ?  (*env)->GetDirectBufferAddress(env, type) :  (*env)->GetPrimitiveArrayCritical(env, type, NULL) );  }
  if ( NULL != name ) {
    _name_ptr = (GLchar *) ( JNI_TRUE == name_is_nio ?  (*env)->GetDirectBufferAddress(env, name) :  (*env)->GetPrimitiveArrayCritical(env, name, NULL) );  }
  glGetActiveUniform((GLuint) program, (GLuint) index, (GLsizei) bufSize, (GLsizei * ) (((char *) _length_ptr) + length_byte_offset), (GLint * ) (((char *) _size_ptr) + size_byte_offset), (GLenum * ) (((char *) _type_ptr) + type_byte_offset), (GLchar * ) (((char *) _name_ptr) + name_byte_offset));
  if ( JNI_FALSE == length_is_nio && NULL != length ) {
    (*env)->ReleasePrimitiveArrayCritical(env, length, _length_ptr, 0);  }
  if ( JNI_FALSE == size_is_nio && NULL != size ) {
    (*env)->ReleasePrimitiveArrayCritical(env, size, _size_ptr, 0);  }
  if ( JNI_FALSE == type_is_nio && NULL != type ) {
    (*env)->ReleasePrimitiveArrayCritical(env, type, _type_ptr, 0);  }
  if ( JNI_FALSE == name_is_nio && NULL != name ) {
    (*env)->ReleasePrimitiveArrayCritical(env, name, _name_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGetAttachedShaders(int program, int maxCount, java.nio.IntBuffer count, java.nio.IntBuffer shaders)
 *     C function: void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *  count, GLuint *  shaders)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetAttachedShaders1__IILjava_lang_Object_2IZLjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint program, jint maxCount, jobject count, jint count_byte_offset, jboolean count_is_nio, jobject shaders, jint shaders_byte_offset, jboolean shaders_is_nio) {
  GLsizei * _count_ptr = NULL;
  GLuint * _shaders_ptr = NULL;
  if ( NULL != count ) {
    _count_ptr = (GLsizei *) ( JNI_TRUE == count_is_nio ?  (*env)->GetDirectBufferAddress(env, count) :  (*env)->GetPrimitiveArrayCritical(env, count, NULL) );  }
  if ( NULL != shaders ) {
    _shaders_ptr = (GLuint *) ( JNI_TRUE == shaders_is_nio ?  (*env)->GetDirectBufferAddress(env, shaders) :  (*env)->GetPrimitiveArrayCritical(env, shaders, NULL) );  }
  glGetAttachedShaders((GLuint) program, (GLsizei) maxCount, (GLsizei * ) (((char *) _count_ptr) + count_byte_offset), (GLuint * ) (((char *) _shaders_ptr) + shaders_byte_offset));
  if ( JNI_FALSE == count_is_nio && NULL != count ) {
    (*env)->ReleasePrimitiveArrayCritical(env, count, _count_ptr, 0);  }
  if ( JNI_FALSE == shaders_is_nio && NULL != shaders ) {
    (*env)->ReleasePrimitiveArrayCritical(env, shaders, _shaders_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: int glGetAttribLocation(int program, java.nio.ByteBuffer name)
 *     C function: GLint glGetAttribLocation(GLuint program, const GLchar *  name)
 */
JNIEXPORT jint JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetAttribLocation1__ILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint program, jobject name, jint name_byte_offset, jboolean name_is_nio) {
  GLchar * _name_ptr = NULL;
  GLint _res;
  if ( NULL != name ) {
    _name_ptr = (GLchar *) ( JNI_TRUE == name_is_nio ?  (*env)->GetDirectBufferAddress(env, name) :  (*env)->GetPrimitiveArrayCritical(env, name, NULL) );  }
  _res = (GLint) glGetAttribLocation((GLuint) program, (const GLchar * ) (((char *) _name_ptr) + name_byte_offset));
  if ( JNI_FALSE == name_is_nio && NULL != name ) {
    (*env)->ReleasePrimitiveArrayCritical(env, name, _name_ptr, JNI_ABORT);  }
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGetBooleanv(int pname, java.nio.ByteBuffer data)
 *     C function: void glGetBooleanv(GLenum pname, GLboolean *  data)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetBooleanv1__ILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint pname, jobject data, jint data_byte_offset, jboolean data_is_nio) {
  GLboolean * _data_ptr = NULL;
  if ( NULL != data ) {
    _data_ptr = (GLboolean *) ( JNI_TRUE == data_is_nio ?  (*env)->GetDirectBufferAddress(env, data) :  (*env)->GetPrimitiveArrayCritical(env, data, NULL) );  }
  glGetBooleanv((GLenum) pname, (GLboolean * ) (((char *) _data_ptr) + data_byte_offset));
  if ( JNI_FALSE == data_is_nio && NULL != data ) {
    (*env)->ReleasePrimitiveArrayCritical(env, data, _data_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGetBufferParameteriv(int target, int pname, java.nio.IntBuffer params)
 *     C function: void glGetBufferParameteriv(GLenum target, GLenum pname, GLint *  params)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetBufferParameteriv1__IILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint target, jint pname, jobject params, jint params_byte_offset, jboolean params_is_nio) {
  GLint * _params_ptr = NULL;
  if ( NULL != params ) {
    _params_ptr = (GLint *) ( JNI_TRUE == params_is_nio ?  (*env)->GetDirectBufferAddress(env, params) :  (*env)->GetPrimitiveArrayCritical(env, params, NULL) );  }
  glGetBufferParameteriv((GLenum) target, (GLenum) pname, (GLint * ) (((char *) _params_ptr) + params_byte_offset));
  if ( JNI_FALSE == params_is_nio && NULL != params ) {
    (*env)->ReleasePrimitiveArrayCritical(env, params, _params_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: int glGetError()
 *     C function: GLenum glGetError()
 */
JNIEXPORT jint JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetError__(JNIEnv *env, jclass _unused) {
  GLenum _res;
  _res = (GLenum) glGetError();
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGetFloatv(int pname, java.nio.FloatBuffer data)
 *     C function: void glGetFloatv(GLenum pname, GLfloat *  data)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetFloatv1__ILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint pname, jobject data, jint data_byte_offset, jboolean data_is_nio) {
  GLfloat * _data_ptr = NULL;
  if ( NULL != data ) {
    _data_ptr = (GLfloat *) ( JNI_TRUE == data_is_nio ?  (*env)->GetDirectBufferAddress(env, data) :  (*env)->GetPrimitiveArrayCritical(env, data, NULL) );  }
  glGetFloatv((GLenum) pname, (GLfloat * ) (((char *) _data_ptr) + data_byte_offset));
  if ( JNI_FALSE == data_is_nio && NULL != data ) {
    (*env)->ReleasePrimitiveArrayCritical(env, data, _data_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGetFramebufferAttachmentParameteriv(int target, int attachment, int pname, java.nio.IntBuffer params)
 *     C function: void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *  params)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetFramebufferAttachmentParameteriv1__IIILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint target, jint attachment, jint pname, jobject params, jint params_byte_offset, jboolean params_is_nio) {
  GLint * _params_ptr = NULL;
  if ( NULL != params ) {
    _params_ptr = (GLint *) ( JNI_TRUE == params_is_nio ?  (*env)->GetDirectBufferAddress(env, params) :  (*env)->GetPrimitiveArrayCritical(env, params, NULL) );  }
  glGetFramebufferAttachmentParameteriv((GLenum) target, (GLenum) attachment, (GLenum) pname, (GLint * ) (((char *) _params_ptr) + params_byte_offset));
  if ( JNI_FALSE == params_is_nio && NULL != params ) {
    (*env)->ReleasePrimitiveArrayCritical(env, params, _params_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGetIntegerv(int pname, java.nio.IntBuffer data)
 *     C function: void glGetIntegerv(GLenum pname, GLint *  data)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetIntegerv1__ILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint pname, jobject data, jint data_byte_offset, jboolean data_is_nio) {
  GLint * _data_ptr = NULL;
  if ( NULL != data ) {
    _data_ptr = (GLint *) ( JNI_TRUE == data_is_nio ?  (*env)->GetDirectBufferAddress(env, data) :  (*env)->GetPrimitiveArrayCritical(env, data, NULL) );  }
  glGetIntegerv((GLenum) pname, (GLint * ) (((char *) _data_ptr) + data_byte_offset));
  if ( JNI_FALSE == data_is_nio && NULL != data ) {
    (*env)->ReleasePrimitiveArrayCritical(env, data, _data_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGetProgramiv(int program, int pname, java.nio.IntBuffer params)
 *     C function: void glGetProgramiv(GLuint program, GLenum pname, GLint *  params)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetProgramiv1__IILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint program, jint pname, jobject params, jint params_byte_offset, jboolean params_is_nio) {
  GLint * _params_ptr = NULL;
  if ( NULL != params ) {
    _params_ptr = (GLint *) ( JNI_TRUE == params_is_nio ?  (*env)->GetDirectBufferAddress(env, params) :  (*env)->GetPrimitiveArrayCritical(env, params, NULL) );  }
  glGetProgramiv((GLuint) program, (GLenum) pname, (GLint * ) (((char *) _params_ptr) + params_byte_offset));
  if ( JNI_FALSE == params_is_nio && NULL != params ) {
    (*env)->ReleasePrimitiveArrayCritical(env, params, _params_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGetProgramInfoLog(int program, int bufSize, java.nio.IntBuffer length, java.nio.ByteBuffer infoLog)
 *     C function: void glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetProgramInfoLog1__IILjava_lang_Object_2IZLjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint program, jint bufSize, jobject length, jint length_byte_offset, jboolean length_is_nio, jobject infoLog, jint infoLog_byte_offset, jboolean infoLog_is_nio) {
  GLsizei * _length_ptr = NULL;
  GLchar * _infoLog_ptr = NULL;
  if ( NULL != length ) {
    _length_ptr = (GLsizei *) ( JNI_TRUE == length_is_nio ?  (*env)->GetDirectBufferAddress(env, length) :  (*env)->GetPrimitiveArrayCritical(env, length, NULL) );  }
  if ( NULL != infoLog ) {
    _infoLog_ptr = (GLchar *) ( JNI_TRUE == infoLog_is_nio ?  (*env)->GetDirectBufferAddress(env, infoLog) :  (*env)->GetPrimitiveArrayCritical(env, infoLog, NULL) );  }
  glGetProgramInfoLog((GLuint) program, (GLsizei) bufSize, (GLsizei * ) (((char *) _length_ptr) + length_byte_offset), (GLchar * ) (((char *) _infoLog_ptr) + infoLog_byte_offset));
  if ( JNI_FALSE == length_is_nio && NULL != length ) {
    (*env)->ReleasePrimitiveArrayCritical(env, length, _length_ptr, 0);  }
  if ( JNI_FALSE == infoLog_is_nio && NULL != infoLog ) {
    (*env)->ReleasePrimitiveArrayCritical(env, infoLog, _infoLog_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGetRenderbufferParameteriv(int target, int pname, java.nio.IntBuffer params)
 *     C function: void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *  params)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetRenderbufferParameteriv1__IILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint target, jint pname, jobject params, jint params_byte_offset, jboolean params_is_nio) {
  GLint * _params_ptr = NULL;
  if ( NULL != params ) {
    _params_ptr = (GLint *) ( JNI_TRUE == params_is_nio ?  (*env)->GetDirectBufferAddress(env, params) :  (*env)->GetPrimitiveArrayCritical(env, params, NULL) );  }
  glGetRenderbufferParameteriv((GLenum) target, (GLenum) pname, (GLint * ) (((char *) _params_ptr) + params_byte_offset));
  if ( JNI_FALSE == params_is_nio && NULL != params ) {
    (*env)->ReleasePrimitiveArrayCritical(env, params, _params_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGetShaderiv(int shader, int pname, java.nio.IntBuffer params)
 *     C function: void glGetShaderiv(GLuint shader, GLenum pname, GLint *  params)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetShaderiv1__IILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint shader, jint pname, jobject params, jint params_byte_offset, jboolean params_is_nio) {
  GLint * _params_ptr = NULL;
  if ( NULL != params ) {
    _params_ptr = (GLint *) ( JNI_TRUE == params_is_nio ?  (*env)->GetDirectBufferAddress(env, params) :  (*env)->GetPrimitiveArrayCritical(env, params, NULL) );  }
  glGetShaderiv((GLuint) shader, (GLenum) pname, (GLint * ) (((char *) _params_ptr) + params_byte_offset));
  if ( JNI_FALSE == params_is_nio && NULL != params ) {
    (*env)->ReleasePrimitiveArrayCritical(env, params, _params_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGetShaderInfoLog(int shader, int bufSize, java.nio.IntBuffer length, java.nio.ByteBuffer infoLog)
 *     C function: void glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetShaderInfoLog1__IILjava_lang_Object_2IZLjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint shader, jint bufSize, jobject length, jint length_byte_offset, jboolean length_is_nio, jobject infoLog, jint infoLog_byte_offset, jboolean infoLog_is_nio) {
  GLsizei * _length_ptr = NULL;
  GLchar * _infoLog_ptr = NULL;
  if ( NULL != length ) {
    _length_ptr = (GLsizei *) ( JNI_TRUE == length_is_nio ?  (*env)->GetDirectBufferAddress(env, length) :  (*env)->GetPrimitiveArrayCritical(env, length, NULL) );  }
  if ( NULL != infoLog ) {
    _infoLog_ptr = (GLchar *) ( JNI_TRUE == infoLog_is_nio ?  (*env)->GetDirectBufferAddress(env, infoLog) :  (*env)->GetPrimitiveArrayCritical(env, infoLog, NULL) );  }
  glGetShaderInfoLog((GLuint) shader, (GLsizei) bufSize, (GLsizei * ) (((char *) _length_ptr) + length_byte_offset), (GLchar * ) (((char *) _infoLog_ptr) + infoLog_byte_offset));
  if ( JNI_FALSE == length_is_nio && NULL != length ) {
    (*env)->ReleasePrimitiveArrayCritical(env, length, _length_ptr, 0);  }
  if ( JNI_FALSE == infoLog_is_nio && NULL != infoLog ) {
    (*env)->ReleasePrimitiveArrayCritical(env, infoLog, _infoLog_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGetShaderPrecisionFormat(int shadertype, int precisiontype, java.nio.IntBuffer range, java.nio.IntBuffer precision)
 *     C function: void glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint *  range, GLint *  precision)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetShaderPrecisionFormat1__IILjava_lang_Object_2IZLjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint shadertype, jint precisiontype, jobject range, jint range_byte_offset, jboolean range_is_nio, jobject precision, jint precision_byte_offset, jboolean precision_is_nio) {
  GLint * _range_ptr = NULL;
  GLint * _precision_ptr = NULL;
  if ( NULL != range ) {
    _range_ptr = (GLint *) ( JNI_TRUE == range_is_nio ?  (*env)->GetDirectBufferAddress(env, range) :  (*env)->GetPrimitiveArrayCritical(env, range, NULL) );  }
  if ( NULL != precision ) {
    _precision_ptr = (GLint *) ( JNI_TRUE == precision_is_nio ?  (*env)->GetDirectBufferAddress(env, precision) :  (*env)->GetPrimitiveArrayCritical(env, precision, NULL) );  }
  glGetShaderPrecisionFormat((GLenum) shadertype, (GLenum) precisiontype, (GLint * ) (((char *) _range_ptr) + range_byte_offset), (GLint * ) (((char *) _precision_ptr) + precision_byte_offset));
  if ( JNI_FALSE == range_is_nio && NULL != range ) {
    (*env)->ReleasePrimitiveArrayCritical(env, range, _range_ptr, 0);  }
  if ( JNI_FALSE == precision_is_nio && NULL != precision ) {
    (*env)->ReleasePrimitiveArrayCritical(env, precision, _precision_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGetShaderSource(int shader, int bufSize, java.nio.IntBuffer length, java.nio.ByteBuffer source)
 *     C function: void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  source)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetShaderSource1__IILjava_lang_Object_2IZLjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint shader, jint bufSize, jobject length, jint length_byte_offset, jboolean length_is_nio, jobject source, jint source_byte_offset, jboolean source_is_nio) {
  GLsizei * _length_ptr = NULL;
  GLchar * _source_ptr = NULL;
  if ( NULL != length ) {
    _length_ptr = (GLsizei *) ( JNI_TRUE == length_is_nio ?  (*env)->GetDirectBufferAddress(env, length) :  (*env)->GetPrimitiveArrayCritical(env, length, NULL) );  }
  if ( NULL != source ) {
    _source_ptr = (GLchar *) ( JNI_TRUE == source_is_nio ?  (*env)->GetDirectBufferAddress(env, source) :  (*env)->GetPrimitiveArrayCritical(env, source, NULL) );  }
  glGetShaderSource((GLuint) shader, (GLsizei) bufSize, (GLsizei * ) (((char *) _length_ptr) + length_byte_offset), (GLchar * ) (((char *) _source_ptr) + source_byte_offset));
  if ( JNI_FALSE == length_is_nio && NULL != length ) {
    (*env)->ReleasePrimitiveArrayCritical(env, length, _length_ptr, 0);  }
  if ( JNI_FALSE == source_is_nio && NULL != source ) {
    (*env)->ReleasePrimitiveArrayCritical(env, source, _source_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: java.nio.ByteBuffer glGetString(int name)
 *     C function: const GLubyte *  glGetString(GLenum name)
 */
JNIEXPORT jobject JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetString1__I(JNIEnv *env, jclass _unused, jint name) {
  GLubyte * _res;
  _res = (GLubyte *) glGetString((GLenum) name);
  jobject _res_jni;
  if(NULL == _res) {
    _res_jni = NULL;
  } else {
    _res_jni = (*env)->NewDirectByteBuffer(env, (void *)_res, sizeof(GLubyte) );
    /** 
     * mode: 20, arg #-1
     * cType: CType[(PointerType) 'GLubyte *' -> (const GLubyte) * , size[fixed false, lnx64 8], const[false], is[pointer*1]]
     * cTargetType: CType[(IntType) typedef 'GLubyte', size[fixed true, lnx64 1], const[native, true], is[primitive, int]]
     * javaType: JType[java.nio.ByteBufferclazz = java.nio.ByteBuffer, is[nioBuffer], descriptor 'Ljava/nio/ByteBuffer;']
     */
  }
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGetTexParameterfv(int target, int pname, java.nio.FloatBuffer params)
 *     C function: void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *  params)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetTexParameterfv1__IILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint target, jint pname, jobject params, jint params_byte_offset, jboolean params_is_nio) {
  GLfloat * _params_ptr = NULL;
  if ( NULL != params ) {
    _params_ptr = (GLfloat *) ( JNI_TRUE == params_is_nio ?  (*env)->GetDirectBufferAddress(env, params) :  (*env)->GetPrimitiveArrayCritical(env, params, NULL) );  }
  glGetTexParameterfv((GLenum) target, (GLenum) pname, (GLfloat * ) (((char *) _params_ptr) + params_byte_offset));
  if ( JNI_FALSE == params_is_nio && NULL != params ) {
    (*env)->ReleasePrimitiveArrayCritical(env, params, _params_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGetTexParameteriv(int target, int pname, java.nio.IntBuffer params)
 *     C function: void glGetTexParameteriv(GLenum target, GLenum pname, GLint *  params)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetTexParameteriv1__IILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint target, jint pname, jobject params, jint params_byte_offset, jboolean params_is_nio) {
  GLint * _params_ptr = NULL;
  if ( NULL != params ) {
    _params_ptr = (GLint *) ( JNI_TRUE == params_is_nio ?  (*env)->GetDirectBufferAddress(env, params) :  (*env)->GetPrimitiveArrayCritical(env, params, NULL) );  }
  glGetTexParameteriv((GLenum) target, (GLenum) pname, (GLint * ) (((char *) _params_ptr) + params_byte_offset));
  if ( JNI_FALSE == params_is_nio && NULL != params ) {
    (*env)->ReleasePrimitiveArrayCritical(env, params, _params_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGetUniformfv(int program, int location, java.nio.FloatBuffer params)
 *     C function: void glGetUniformfv(GLuint program, GLint location, GLfloat *  params)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetUniformfv1__IILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint program, jint location, jobject params, jint params_byte_offset, jboolean params_is_nio) {
  GLfloat * _params_ptr = NULL;
  if ( NULL != params ) {
    _params_ptr = (GLfloat *) ( JNI_TRUE == params_is_nio ?  (*env)->GetDirectBufferAddress(env, params) :  (*env)->GetPrimitiveArrayCritical(env, params, NULL) );  }
  glGetUniformfv((GLuint) program, (GLint) location, (GLfloat * ) (((char *) _params_ptr) + params_byte_offset));
  if ( JNI_FALSE == params_is_nio && NULL != params ) {
    (*env)->ReleasePrimitiveArrayCritical(env, params, _params_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGetUniformiv(int program, int location, java.nio.IntBuffer params)
 *     C function: void glGetUniformiv(GLuint program, GLint location, GLint *  params)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetUniformiv1__IILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint program, jint location, jobject params, jint params_byte_offset, jboolean params_is_nio) {
  GLint * _params_ptr = NULL;
  if ( NULL != params ) {
    _params_ptr = (GLint *) ( JNI_TRUE == params_is_nio ?  (*env)->GetDirectBufferAddress(env, params) :  (*env)->GetPrimitiveArrayCritical(env, params, NULL) );  }
  glGetUniformiv((GLuint) program, (GLint) location, (GLint * ) (((char *) _params_ptr) + params_byte_offset));
  if ( JNI_FALSE == params_is_nio && NULL != params ) {
    (*env)->ReleasePrimitiveArrayCritical(env, params, _params_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: int glGetUniformLocation(int program, java.nio.ByteBuffer name)
 *     C function: GLint glGetUniformLocation(GLuint program, const GLchar *  name)
 */
JNIEXPORT jint JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetUniformLocation1__ILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint program, jobject name, jint name_byte_offset, jboolean name_is_nio) {
  GLchar * _name_ptr = NULL;
  GLint _res;
  if ( NULL != name ) {
    _name_ptr = (GLchar *) ( JNI_TRUE == name_is_nio ?  (*env)->GetDirectBufferAddress(env, name) :  (*env)->GetPrimitiveArrayCritical(env, name, NULL) );  }
  _res = (GLint) glGetUniformLocation((GLuint) program, (const GLchar * ) (((char *) _name_ptr) + name_byte_offset));
  if ( JNI_FALSE == name_is_nio && NULL != name ) {
    (*env)->ReleasePrimitiveArrayCritical(env, name, _name_ptr, JNI_ABORT);  }
  jint _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGetVertexAttribfv(int index, int pname, java.nio.FloatBuffer params)
 *     C function: void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *  params)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetVertexAttribfv1__IILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint index, jint pname, jobject params, jint params_byte_offset, jboolean params_is_nio) {
  GLfloat * _params_ptr = NULL;
  if ( NULL != params ) {
    _params_ptr = (GLfloat *) ( JNI_TRUE == params_is_nio ?  (*env)->GetDirectBufferAddress(env, params) :  (*env)->GetPrimitiveArrayCritical(env, params, NULL) );  }
  glGetVertexAttribfv((GLuint) index, (GLenum) pname, (GLfloat * ) (((char *) _params_ptr) + params_byte_offset));
  if ( JNI_FALSE == params_is_nio && NULL != params ) {
    (*env)->ReleasePrimitiveArrayCritical(env, params, _params_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGetVertexAttribiv(int index, int pname, java.nio.IntBuffer params)
 *     C function: void glGetVertexAttribiv(GLuint index, GLenum pname, GLint *  params)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetVertexAttribiv1__IILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint index, jint pname, jobject params, jint params_byte_offset, jboolean params_is_nio) {
  GLint * _params_ptr = NULL;
  if ( NULL != params ) {
    _params_ptr = (GLint *) ( JNI_TRUE == params_is_nio ?  (*env)->GetDirectBufferAddress(env, params) :  (*env)->GetPrimitiveArrayCritical(env, params, NULL) );  }
  glGetVertexAttribiv((GLuint) index, (GLenum) pname, (GLint * ) (((char *) _params_ptr) + params_byte_offset));
  if ( JNI_FALSE == params_is_nio && NULL != params ) {
    (*env)->ReleasePrimitiveArrayCritical(env, params, _params_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glGetVertexAttribPointerv(int index, int pname, com.jogamp.common.nio.PointerBuffer pointer)
 *     C function: void glGetVertexAttribPointerv(GLuint index, GLenum pname, void *  *  pointer)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glGetVertexAttribPointerv1__IILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint index, jint pname, jobject pointer, jint pointer_byte_offset, jboolean pointer_is_nio) {
  void * * _pointer_ptr = NULL;
  if ( NULL != pointer ) {
    _pointer_ptr = (void * *) ( JNI_TRUE == pointer_is_nio ?  (*env)->GetDirectBufferAddress(env, pointer) :  (*env)->GetPrimitiveArrayCritical(env, pointer, NULL) );  }
  glGetVertexAttribPointerv((GLuint) index, (GLenum) pname, (void *  * ) (((char *) _pointer_ptr) + pointer_byte_offset));
  if ( JNI_FALSE == pointer_is_nio && NULL != pointer ) {
    (*env)->ReleasePrimitiveArrayCritical(env, pointer, _pointer_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glHint(int target, int mode)
 *     C function: void glHint(GLenum target, GLenum mode)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glHint__II(JNIEnv *env, jclass _unused, jint target, jint mode) {
  glHint((GLenum) target, (GLenum) mode);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: byte glIsBuffer(int buffer)
 *     C function: GLboolean glIsBuffer(GLuint buffer)
 */
JNIEXPORT jbyte JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glIsBuffer__I(JNIEnv *env, jclass _unused, jint buffer) {
  GLboolean _res;
  _res = (GLboolean) glIsBuffer((GLuint) buffer);
  jbyte _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: byte glIsEnabled(int cap)
 *     C function: GLboolean glIsEnabled(GLenum cap)
 */
JNIEXPORT jbyte JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glIsEnabled__I(JNIEnv *env, jclass _unused, jint cap) {
  GLboolean _res;
  _res = (GLboolean) glIsEnabled((GLenum) cap);
  jbyte _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: byte glIsFramebuffer(int framebuffer)
 *     C function: GLboolean glIsFramebuffer(GLuint framebuffer)
 */
JNIEXPORT jbyte JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glIsFramebuffer__I(JNIEnv *env, jclass _unused, jint framebuffer) {
  GLboolean _res;
  _res = (GLboolean) glIsFramebuffer((GLuint) framebuffer);
  jbyte _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: byte glIsProgram(int program)
 *     C function: GLboolean glIsProgram(GLuint program)
 */
JNIEXPORT jbyte JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glIsProgram__I(JNIEnv *env, jclass _unused, jint program) {
  GLboolean _res;
  _res = (GLboolean) glIsProgram((GLuint) program);
  jbyte _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: byte glIsRenderbuffer(int renderbuffer)
 *     C function: GLboolean glIsRenderbuffer(GLuint renderbuffer)
 */
JNIEXPORT jbyte JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glIsRenderbuffer__I(JNIEnv *env, jclass _unused, jint renderbuffer) {
  GLboolean _res;
  _res = (GLboolean) glIsRenderbuffer((GLuint) renderbuffer);
  jbyte _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: byte glIsShader(int shader)
 *     C function: GLboolean glIsShader(GLuint shader)
 */
JNIEXPORT jbyte JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glIsShader__I(JNIEnv *env, jclass _unused, jint shader) {
  GLboolean _res;
  _res = (GLboolean) glIsShader((GLuint) shader);
  jbyte _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: byte glIsTexture(int texture)
 *     C function: GLboolean glIsTexture(GLuint texture)
 */
JNIEXPORT jbyte JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glIsTexture__I(JNIEnv *env, jclass _unused, jint texture) {
  GLboolean _res;
  _res = (GLboolean) glIsTexture((GLuint) texture);
  jbyte _res_jni = _res;
  return _res_jni;
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glLineWidth(float width)
 *     C function: void glLineWidth(GLfloat width)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glLineWidth__F(JNIEnv *env, jclass _unused, jfloat width) {
  glLineWidth((GLfloat) width);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glLinkProgram(int program)
 *     C function: void glLinkProgram(GLuint program)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glLinkProgram__I(JNIEnv *env, jclass _unused, jint program) {
  glLinkProgram((GLuint) program);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glPixelStorei(int pname, int param)
 *     C function: void glPixelStorei(GLenum pname, GLint param)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glPixelStorei__II(JNIEnv *env, jclass _unused, jint pname, jint param) {
  glPixelStorei((GLenum) pname, (GLint) param);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glPolygonOffset(float factor, float units)
 *     C function: void glPolygonOffset(GLfloat factor, GLfloat units)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glPolygonOffset__FF(JNIEnv *env, jclass _unused, jfloat factor, jfloat units) {
  glPolygonOffset((GLfloat) factor, (GLfloat) units);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glReadPixels(int x, int y, int width, int height, int format, int type, java.nio.Buffer pixels)
 *     C function: void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *  pixels)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glReadPixels1__IIIIIILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint x, jint y, jint width, jint height, jint format, jint type, jobject pixels, jint pixels_byte_offset, jboolean pixels_is_nio) {
  void * _pixels_ptr = NULL;
  if ( NULL != pixels ) {
    _pixels_ptr = (void *) ( JNI_TRUE == pixels_is_nio ?  (*env)->GetDirectBufferAddress(env, pixels) :  (*env)->GetPrimitiveArrayCritical(env, pixels, NULL) );  }
  glReadPixels((GLint) x, (GLint) y, (GLsizei) width, (GLsizei) height, (GLenum) format, (GLenum) type, (void * ) (((char *) _pixels_ptr) + pixels_byte_offset));
  if ( JNI_FALSE == pixels_is_nio && NULL != pixels ) {
    (*env)->ReleasePrimitiveArrayCritical(env, pixels, _pixels_ptr, 0);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glReleaseShaderCompiler()
 *     C function: void glReleaseShaderCompiler()
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glReleaseShaderCompiler__(JNIEnv *env, jclass _unused) {
  glReleaseShaderCompiler();
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glRenderbufferStorage(int target, int internalformat, int width, int height)
 *     C function: void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glRenderbufferStorage__IIII(JNIEnv *env, jclass _unused, jint target, jint internalformat, jint width, jint height) {
  glRenderbufferStorage((GLenum) target, (GLenum) internalformat, (GLsizei) width, (GLsizei) height);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glSampleCoverage(float value, byte invert)
 *     C function: void glSampleCoverage(GLfloat value, GLboolean invert)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glSampleCoverage__FB(JNIEnv *env, jclass _unused, jfloat value, jbyte invert) {
  glSampleCoverage((GLfloat) value, (GLboolean) invert);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glScissor(int x, int y, int width, int height)
 *     C function: void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glScissor__IIII(JNIEnv *env, jclass _unused, jint x, jint y, jint width, jint height) {
  glScissor((GLint) x, (GLint) y, (GLsizei) width, (GLsizei) height);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glShaderBinary(int count, java.nio.IntBuffer shaders, int binaryFormat, java.nio.Buffer binary, int length)
 *     C function: void glShaderBinary(GLsizei count, const GLuint *  shaders, GLenum binaryFormat, const void *  binary, GLsizei length)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glShaderBinary1__ILjava_lang_Object_2IZILjava_lang_Object_2IZI(JNIEnv *env, jclass _unused, jint count, jobject shaders, jint shaders_byte_offset, jboolean shaders_is_nio, jint binaryFormat, jobject binary, jint binary_byte_offset, jboolean binary_is_nio, jint length) {
  GLuint * _shaders_ptr = NULL;
  void * _binary_ptr = NULL;
  if ( NULL != shaders ) {
    _shaders_ptr = (GLuint *) ( JNI_TRUE == shaders_is_nio ?  (*env)->GetDirectBufferAddress(env, shaders) :  (*env)->GetPrimitiveArrayCritical(env, shaders, NULL) );  }
  if ( NULL != binary ) {
    _binary_ptr = (void *) ( JNI_TRUE == binary_is_nio ?  (*env)->GetDirectBufferAddress(env, binary) :  (*env)->GetPrimitiveArrayCritical(env, binary, NULL) );  }
  glShaderBinary((GLsizei) count, (const GLuint * ) (((char *) _shaders_ptr) + shaders_byte_offset), (GLenum) binaryFormat, (const void * ) (((char *) _binary_ptr) + binary_byte_offset), (GLsizei) length);
  if ( JNI_FALSE == shaders_is_nio && NULL != shaders ) {
    (*env)->ReleasePrimitiveArrayCritical(env, shaders, _shaders_ptr, JNI_ABORT);  }
  if ( JNI_FALSE == binary_is_nio && NULL != binary ) {
    (*env)->ReleasePrimitiveArrayCritical(env, binary, _binary_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glShaderSource(int shader, int count, com.jogamp.common.nio.PointerBuffer string, java.nio.IntBuffer length)
 *     C function: void glShaderSource(GLuint shader, GLsizei count, const GLchar * const  *  string, const GLint *  length)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glShaderSource1__IILjava_lang_Object_2IZLjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint shader, jint count, jobject string, jint string_byte_offset, jboolean string_is_nio, jobject length, jint length_byte_offset, jboolean length_is_nio) {
  GLchar * * _string_ptr = NULL;
  GLint * _length_ptr = NULL;
  if ( NULL != string ) {
    _string_ptr = (GLchar * *) ( JNI_TRUE == string_is_nio ?  (*env)->GetDirectBufferAddress(env, string) :  (*env)->GetPrimitiveArrayCritical(env, string, NULL) );  }
  if ( NULL != length ) {
    _length_ptr = (GLint *) ( JNI_TRUE == length_is_nio ?  (*env)->GetDirectBufferAddress(env, length) :  (*env)->GetPrimitiveArrayCritical(env, length, NULL) );  }
  glShaderSource((GLuint) shader, (GLsizei) count, (const GLchar * const  * ) (((char *) _string_ptr) + string_byte_offset), (const GLint * ) (((char *) _length_ptr) + length_byte_offset));
  if ( JNI_FALSE == string_is_nio && NULL != string ) {
    (*env)->ReleasePrimitiveArrayCritical(env, string, _string_ptr, JNI_ABORT);  }
  if ( JNI_FALSE == length_is_nio && NULL != length ) {
    (*env)->ReleasePrimitiveArrayCritical(env, length, _length_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glStencilFunc(int func, int ref, int mask)
 *     C function: void glStencilFunc(GLenum func, GLint ref, GLuint mask)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glStencilFunc__III(JNIEnv *env, jclass _unused, jint func, jint ref, jint mask) {
  glStencilFunc((GLenum) func, (GLint) ref, (GLuint) mask);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glStencilFuncSeparate(int face, int func, int ref, int mask)
 *     C function: void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glStencilFuncSeparate__IIII(JNIEnv *env, jclass _unused, jint face, jint func, jint ref, jint mask) {
  glStencilFuncSeparate((GLenum) face, (GLenum) func, (GLint) ref, (GLuint) mask);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glStencilMask(int mask)
 *     C function: void glStencilMask(GLuint mask)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glStencilMask__I(JNIEnv *env, jclass _unused, jint mask) {
  glStencilMask((GLuint) mask);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glStencilMaskSeparate(int face, int mask)
 *     C function: void glStencilMaskSeparate(GLenum face, GLuint mask)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glStencilMaskSeparate__II(JNIEnv *env, jclass _unused, jint face, jint mask) {
  glStencilMaskSeparate((GLenum) face, (GLuint) mask);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glStencilOp(int fail, int zfail, int zpass)
 *     C function: void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glStencilOp__III(JNIEnv *env, jclass _unused, jint fail, jint zfail, jint zpass) {
  glStencilOp((GLenum) fail, (GLenum) zfail, (GLenum) zpass);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glStencilOpSeparate(int face, int sfail, int dpfail, int dppass)
 *     C function: void glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glStencilOpSeparate__IIII(JNIEnv *env, jclass _unused, jint face, jint sfail, jint dpfail, jint dppass) {
  glStencilOpSeparate((GLenum) face, (GLenum) sfail, (GLenum) dpfail, (GLenum) dppass);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glTexImage2D(int target, int level, int internalformat, int width, int height, int border, int format, int type, java.nio.Buffer pixels)
 *     C function: void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *  pixels)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glTexImage2D1__IIIIIIIILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint target, jint level, jint internalformat, jint width, jint height, jint border, jint format, jint type, jobject pixels, jint pixels_byte_offset, jboolean pixels_is_nio) {
  void * _pixels_ptr = NULL;
  if ( NULL != pixels ) {
    _pixels_ptr = (void *) ( JNI_TRUE == pixels_is_nio ?  (*env)->GetDirectBufferAddress(env, pixels) :  (*env)->GetPrimitiveArrayCritical(env, pixels, NULL) );  }
  glTexImage2D((GLenum) target, (GLint) level, (GLint) internalformat, (GLsizei) width, (GLsizei) height, (GLint) border, (GLenum) format, (GLenum) type, (const void * ) (((char *) _pixels_ptr) + pixels_byte_offset));
  if ( JNI_FALSE == pixels_is_nio && NULL != pixels ) {
    (*env)->ReleasePrimitiveArrayCritical(env, pixels, _pixels_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glTexParameterf(int target, int pname, float param)
 *     C function: void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glTexParameterf__IIF(JNIEnv *env, jclass _unused, jint target, jint pname, jfloat param) {
  glTexParameterf((GLenum) target, (GLenum) pname, (GLfloat) param);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glTexParameterfv(int target, int pname, java.nio.FloatBuffer params)
 *     C function: void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *  params)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glTexParameterfv1__IILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint target, jint pname, jobject params, jint params_byte_offset, jboolean params_is_nio) {
  GLfloat * _params_ptr = NULL;
  if ( NULL != params ) {
    _params_ptr = (GLfloat *) ( JNI_TRUE == params_is_nio ?  (*env)->GetDirectBufferAddress(env, params) :  (*env)->GetPrimitiveArrayCritical(env, params, NULL) );  }
  glTexParameterfv((GLenum) target, (GLenum) pname, (const GLfloat * ) (((char *) _params_ptr) + params_byte_offset));
  if ( JNI_FALSE == params_is_nio && NULL != params ) {
    (*env)->ReleasePrimitiveArrayCritical(env, params, _params_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glTexParameteri(int target, int pname, int param)
 *     C function: void glTexParameteri(GLenum target, GLenum pname, GLint param)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glTexParameteri__III(JNIEnv *env, jclass _unused, jint target, jint pname, jint param) {
  glTexParameteri((GLenum) target, (GLenum) pname, (GLint) param);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glTexParameteriv(int target, int pname, java.nio.IntBuffer params)
 *     C function: void glTexParameteriv(GLenum target, GLenum pname, const GLint *  params)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glTexParameteriv1__IILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint target, jint pname, jobject params, jint params_byte_offset, jboolean params_is_nio) {
  GLint * _params_ptr = NULL;
  if ( NULL != params ) {
    _params_ptr = (GLint *) ( JNI_TRUE == params_is_nio ?  (*env)->GetDirectBufferAddress(env, params) :  (*env)->GetPrimitiveArrayCritical(env, params, NULL) );  }
  glTexParameteriv((GLenum) target, (GLenum) pname, (const GLint * ) (((char *) _params_ptr) + params_byte_offset));
  if ( JNI_FALSE == params_is_nio && NULL != params ) {
    (*env)->ReleasePrimitiveArrayCritical(env, params, _params_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, java.nio.Buffer pixels)
 *     C function: void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  pixels)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glTexSubImage2D1__IIIIIIIILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint target, jint level, jint xoffset, jint yoffset, jint width, jint height, jint format, jint type, jobject pixels, jint pixels_byte_offset, jboolean pixels_is_nio) {
  void * _pixels_ptr = NULL;
  if ( NULL != pixels ) {
    _pixels_ptr = (void *) ( JNI_TRUE == pixels_is_nio ?  (*env)->GetDirectBufferAddress(env, pixels) :  (*env)->GetPrimitiveArrayCritical(env, pixels, NULL) );  }
  glTexSubImage2D((GLenum) target, (GLint) level, (GLint) xoffset, (GLint) yoffset, (GLsizei) width, (GLsizei) height, (GLenum) format, (GLenum) type, (const void * ) (((char *) _pixels_ptr) + pixels_byte_offset));
  if ( JNI_FALSE == pixels_is_nio && NULL != pixels ) {
    (*env)->ReleasePrimitiveArrayCritical(env, pixels, _pixels_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glUniform1f(int location, float v0)
 *     C function: void glUniform1f(GLint location, GLfloat v0)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glUniform1f__IF(JNIEnv *env, jclass _unused, jint location, jfloat v0) {
  glUniform1f((GLint) location, (GLfloat) v0);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glUniform1fv(int location, int count, java.nio.FloatBuffer value)
 *     C function: void glUniform1fv(GLint location, GLsizei count, const GLfloat *  value)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glUniform1fv1__IILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint location, jint count, jobject value, jint value_byte_offset, jboolean value_is_nio) {
  GLfloat * _value_ptr = NULL;
  if ( NULL != value ) {
    _value_ptr = (GLfloat *) ( JNI_TRUE == value_is_nio ?  (*env)->GetDirectBufferAddress(env, value) :  (*env)->GetPrimitiveArrayCritical(env, value, NULL) );  }
  glUniform1fv((GLint) location, (GLsizei) count, (const GLfloat * ) (((char *) _value_ptr) + value_byte_offset));
  if ( JNI_FALSE == value_is_nio && NULL != value ) {
    (*env)->ReleasePrimitiveArrayCritical(env, value, _value_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glUniform1i(int location, int v0)
 *     C function: void glUniform1i(GLint location, GLint v0)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glUniform1i__II(JNIEnv *env, jclass _unused, jint location, jint v0) {
  glUniform1i((GLint) location, (GLint) v0);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glUniform1iv(int location, int count, java.nio.IntBuffer value)
 *     C function: void glUniform1iv(GLint location, GLsizei count, const GLint *  value)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glUniform1iv1__IILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint location, jint count, jobject value, jint value_byte_offset, jboolean value_is_nio) {
  GLint * _value_ptr = NULL;
  if ( NULL != value ) {
    _value_ptr = (GLint *) ( JNI_TRUE == value_is_nio ?  (*env)->GetDirectBufferAddress(env, value) :  (*env)->GetPrimitiveArrayCritical(env, value, NULL) );  }
  glUniform1iv((GLint) location, (GLsizei) count, (const GLint * ) (((char *) _value_ptr) + value_byte_offset));
  if ( JNI_FALSE == value_is_nio && NULL != value ) {
    (*env)->ReleasePrimitiveArrayCritical(env, value, _value_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glUniform2f(int location, float v0, float v1)
 *     C function: void glUniform2f(GLint location, GLfloat v0, GLfloat v1)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glUniform2f__IFF(JNIEnv *env, jclass _unused, jint location, jfloat v0, jfloat v1) {
  glUniform2f((GLint) location, (GLfloat) v0, (GLfloat) v1);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glUniform2fv(int location, int count, java.nio.FloatBuffer value)
 *     C function: void glUniform2fv(GLint location, GLsizei count, const GLfloat *  value)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glUniform2fv1__IILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint location, jint count, jobject value, jint value_byte_offset, jboolean value_is_nio) {
  GLfloat * _value_ptr = NULL;
  if ( NULL != value ) {
    _value_ptr = (GLfloat *) ( JNI_TRUE == value_is_nio ?  (*env)->GetDirectBufferAddress(env, value) :  (*env)->GetPrimitiveArrayCritical(env, value, NULL) );  }
  glUniform2fv((GLint) location, (GLsizei) count, (const GLfloat * ) (((char *) _value_ptr) + value_byte_offset));
  if ( JNI_FALSE == value_is_nio && NULL != value ) {
    (*env)->ReleasePrimitiveArrayCritical(env, value, _value_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glUniform2i(int location, int v0, int v1)
 *     C function: void glUniform2i(GLint location, GLint v0, GLint v1)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glUniform2i__III(JNIEnv *env, jclass _unused, jint location, jint v0, jint v1) {
  glUniform2i((GLint) location, (GLint) v0, (GLint) v1);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glUniform2iv(int location, int count, java.nio.IntBuffer value)
 *     C function: void glUniform2iv(GLint location, GLsizei count, const GLint *  value)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glUniform2iv1__IILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint location, jint count, jobject value, jint value_byte_offset, jboolean value_is_nio) {
  GLint * _value_ptr = NULL;
  if ( NULL != value ) {
    _value_ptr = (GLint *) ( JNI_TRUE == value_is_nio ?  (*env)->GetDirectBufferAddress(env, value) :  (*env)->GetPrimitiveArrayCritical(env, value, NULL) );  }
  glUniform2iv((GLint) location, (GLsizei) count, (const GLint * ) (((char *) _value_ptr) + value_byte_offset));
  if ( JNI_FALSE == value_is_nio && NULL != value ) {
    (*env)->ReleasePrimitiveArrayCritical(env, value, _value_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glUniform3f(int location, float v0, float v1, float v2)
 *     C function: void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glUniform3f__IFFF(JNIEnv *env, jclass _unused, jint location, jfloat v0, jfloat v1, jfloat v2) {
  glUniform3f((GLint) location, (GLfloat) v0, (GLfloat) v1, (GLfloat) v2);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glUniform3fv(int location, int count, java.nio.FloatBuffer value)
 *     C function: void glUniform3fv(GLint location, GLsizei count, const GLfloat *  value)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glUniform3fv1__IILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint location, jint count, jobject value, jint value_byte_offset, jboolean value_is_nio) {
  GLfloat * _value_ptr = NULL;
  if ( NULL != value ) {
    _value_ptr = (GLfloat *) ( JNI_TRUE == value_is_nio ?  (*env)->GetDirectBufferAddress(env, value) :  (*env)->GetPrimitiveArrayCritical(env, value, NULL) );  }
  glUniform3fv((GLint) location, (GLsizei) count, (const GLfloat * ) (((char *) _value_ptr) + value_byte_offset));
  if ( JNI_FALSE == value_is_nio && NULL != value ) {
    (*env)->ReleasePrimitiveArrayCritical(env, value, _value_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glUniform3i(int location, int v0, int v1, int v2)
 *     C function: void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glUniform3i__IIII(JNIEnv *env, jclass _unused, jint location, jint v0, jint v1, jint v2) {
  glUniform3i((GLint) location, (GLint) v0, (GLint) v1, (GLint) v2);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glUniform3iv(int location, int count, java.nio.IntBuffer value)
 *     C function: void glUniform3iv(GLint location, GLsizei count, const GLint *  value)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glUniform3iv1__IILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint location, jint count, jobject value, jint value_byte_offset, jboolean value_is_nio) {
  GLint * _value_ptr = NULL;
  if ( NULL != value ) {
    _value_ptr = (GLint *) ( JNI_TRUE == value_is_nio ?  (*env)->GetDirectBufferAddress(env, value) :  (*env)->GetPrimitiveArrayCritical(env, value, NULL) );  }
  glUniform3iv((GLint) location, (GLsizei) count, (const GLint * ) (((char *) _value_ptr) + value_byte_offset));
  if ( JNI_FALSE == value_is_nio && NULL != value ) {
    (*env)->ReleasePrimitiveArrayCritical(env, value, _value_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glUniform4f(int location, float v0, float v1, float v2, float v3)
 *     C function: void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glUniform4f__IFFFF(JNIEnv *env, jclass _unused, jint location, jfloat v0, jfloat v1, jfloat v2, jfloat v3) {
  glUniform4f((GLint) location, (GLfloat) v0, (GLfloat) v1, (GLfloat) v2, (GLfloat) v3);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glUniform4fv(int location, int count, java.nio.FloatBuffer value)
 *     C function: void glUniform4fv(GLint location, GLsizei count, const GLfloat *  value)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glUniform4fv1__IILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint location, jint count, jobject value, jint value_byte_offset, jboolean value_is_nio) {
  GLfloat * _value_ptr = NULL;
  if ( NULL != value ) {
    _value_ptr = (GLfloat *) ( JNI_TRUE == value_is_nio ?  (*env)->GetDirectBufferAddress(env, value) :  (*env)->GetPrimitiveArrayCritical(env, value, NULL) );  }
  glUniform4fv((GLint) location, (GLsizei) count, (const GLfloat * ) (((char *) _value_ptr) + value_byte_offset));
  if ( JNI_FALSE == value_is_nio && NULL != value ) {
    (*env)->ReleasePrimitiveArrayCritical(env, value, _value_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glUniform4i(int location, int v0, int v1, int v2, int v3)
 *     C function: void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glUniform4i__IIIII(JNIEnv *env, jclass _unused, jint location, jint v0, jint v1, jint v2, jint v3) {
  glUniform4i((GLint) location, (GLint) v0, (GLint) v1, (GLint) v2, (GLint) v3);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glUniform4iv(int location, int count, java.nio.IntBuffer value)
 *     C function: void glUniform4iv(GLint location, GLsizei count, const GLint *  value)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glUniform4iv1__IILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint location, jint count, jobject value, jint value_byte_offset, jboolean value_is_nio) {
  GLint * _value_ptr = NULL;
  if ( NULL != value ) {
    _value_ptr = (GLint *) ( JNI_TRUE == value_is_nio ?  (*env)->GetDirectBufferAddress(env, value) :  (*env)->GetPrimitiveArrayCritical(env, value, NULL) );  }
  glUniform4iv((GLint) location, (GLsizei) count, (const GLint * ) (((char *) _value_ptr) + value_byte_offset));
  if ( JNI_FALSE == value_is_nio && NULL != value ) {
    (*env)->ReleasePrimitiveArrayCritical(env, value, _value_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glUniformMatrix2fv(int location, int count, byte transpose, java.nio.FloatBuffer value)
 *     C function: void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glUniformMatrix2fv1__IIBLjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint location, jint count, jbyte transpose, jobject value, jint value_byte_offset, jboolean value_is_nio) {
  GLfloat * _value_ptr = NULL;
  if ( NULL != value ) {
    _value_ptr = (GLfloat *) ( JNI_TRUE == value_is_nio ?  (*env)->GetDirectBufferAddress(env, value) :  (*env)->GetPrimitiveArrayCritical(env, value, NULL) );  }
  glUniformMatrix2fv((GLint) location, (GLsizei) count, (GLboolean) transpose, (const GLfloat * ) (((char *) _value_ptr) + value_byte_offset));
  if ( JNI_FALSE == value_is_nio && NULL != value ) {
    (*env)->ReleasePrimitiveArrayCritical(env, value, _value_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glUniformMatrix3fv(int location, int count, byte transpose, java.nio.FloatBuffer value)
 *     C function: void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glUniformMatrix3fv1__IIBLjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint location, jint count, jbyte transpose, jobject value, jint value_byte_offset, jboolean value_is_nio) {
  GLfloat * _value_ptr = NULL;
  if ( NULL != value ) {
    _value_ptr = (GLfloat *) ( JNI_TRUE == value_is_nio ?  (*env)->GetDirectBufferAddress(env, value) :  (*env)->GetPrimitiveArrayCritical(env, value, NULL) );  }
  glUniformMatrix3fv((GLint) location, (GLsizei) count, (GLboolean) transpose, (const GLfloat * ) (((char *) _value_ptr) + value_byte_offset));
  if ( JNI_FALSE == value_is_nio && NULL != value ) {
    (*env)->ReleasePrimitiveArrayCritical(env, value, _value_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glUniformMatrix4fv(int location, int count, byte transpose, java.nio.FloatBuffer value)
 *     C function: void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glUniformMatrix4fv1__IIBLjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint location, jint count, jbyte transpose, jobject value, jint value_byte_offset, jboolean value_is_nio) {
  GLfloat * _value_ptr = NULL;
  if ( NULL != value ) {
    _value_ptr = (GLfloat *) ( JNI_TRUE == value_is_nio ?  (*env)->GetDirectBufferAddress(env, value) :  (*env)->GetPrimitiveArrayCritical(env, value, NULL) );  }
  glUniformMatrix4fv((GLint) location, (GLsizei) count, (GLboolean) transpose, (const GLfloat * ) (((char *) _value_ptr) + value_byte_offset));
  if ( JNI_FALSE == value_is_nio && NULL != value ) {
    (*env)->ReleasePrimitiveArrayCritical(env, value, _value_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glUseProgram(int program)
 *     C function: void glUseProgram(GLuint program)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glUseProgram__I(JNIEnv *env, jclass _unused, jint program) {
  glUseProgram((GLuint) program);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glValidateProgram(int program)
 *     C function: void glValidateProgram(GLuint program)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glValidateProgram__I(JNIEnv *env, jclass _unused, jint program) {
  glValidateProgram((GLuint) program);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glVertexAttrib1f(int index, float x)
 *     C function: void glVertexAttrib1f(GLuint index, GLfloat x)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glVertexAttrib1f__IF(JNIEnv *env, jclass _unused, jint index, jfloat x) {
  glVertexAttrib1f((GLuint) index, (GLfloat) x);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glVertexAttrib1fv(int index, java.nio.FloatBuffer v)
 *     C function: void glVertexAttrib1fv(GLuint index, const GLfloat *  v)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glVertexAttrib1fv1__ILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint index, jobject v, jint v_byte_offset, jboolean v_is_nio) {
  GLfloat * _v_ptr = NULL;
  if ( NULL != v ) {
    _v_ptr = (GLfloat *) ( JNI_TRUE == v_is_nio ?  (*env)->GetDirectBufferAddress(env, v) :  (*env)->GetPrimitiveArrayCritical(env, v, NULL) );  }
  glVertexAttrib1fv((GLuint) index, (const GLfloat * ) (((char *) _v_ptr) + v_byte_offset));
  if ( JNI_FALSE == v_is_nio && NULL != v ) {
    (*env)->ReleasePrimitiveArrayCritical(env, v, _v_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glVertexAttrib2f(int index, float x, float y)
 *     C function: void glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glVertexAttrib2f__IFF(JNIEnv *env, jclass _unused, jint index, jfloat x, jfloat y) {
  glVertexAttrib2f((GLuint) index, (GLfloat) x, (GLfloat) y);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glVertexAttrib2fv(int index, java.nio.FloatBuffer v)
 *     C function: void glVertexAttrib2fv(GLuint index, const GLfloat *  v)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glVertexAttrib2fv1__ILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint index, jobject v, jint v_byte_offset, jboolean v_is_nio) {
  GLfloat * _v_ptr = NULL;
  if ( NULL != v ) {
    _v_ptr = (GLfloat *) ( JNI_TRUE == v_is_nio ?  (*env)->GetDirectBufferAddress(env, v) :  (*env)->GetPrimitiveArrayCritical(env, v, NULL) );  }
  glVertexAttrib2fv((GLuint) index, (const GLfloat * ) (((char *) _v_ptr) + v_byte_offset));
  if ( JNI_FALSE == v_is_nio && NULL != v ) {
    (*env)->ReleasePrimitiveArrayCritical(env, v, _v_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glVertexAttrib3f(int index, float x, float y, float z)
 *     C function: void glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glVertexAttrib3f__IFFF(JNIEnv *env, jclass _unused, jint index, jfloat x, jfloat y, jfloat z) {
  glVertexAttrib3f((GLuint) index, (GLfloat) x, (GLfloat) y, (GLfloat) z);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glVertexAttrib3fv(int index, java.nio.FloatBuffer v)
 *     C function: void glVertexAttrib3fv(GLuint index, const GLfloat *  v)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glVertexAttrib3fv1__ILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint index, jobject v, jint v_byte_offset, jboolean v_is_nio) {
  GLfloat * _v_ptr = NULL;
  if ( NULL != v ) {
    _v_ptr = (GLfloat *) ( JNI_TRUE == v_is_nio ?  (*env)->GetDirectBufferAddress(env, v) :  (*env)->GetPrimitiveArrayCritical(env, v, NULL) );  }
  glVertexAttrib3fv((GLuint) index, (const GLfloat * ) (((char *) _v_ptr) + v_byte_offset));
  if ( JNI_FALSE == v_is_nio && NULL != v ) {
    (*env)->ReleasePrimitiveArrayCritical(env, v, _v_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glVertexAttrib4f(int index, float x, float y, float z, float w)
 *     C function: void glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glVertexAttrib4f__IFFFF(JNIEnv *env, jclass _unused, jint index, jfloat x, jfloat y, jfloat z, jfloat w) {
  glVertexAttrib4f((GLuint) index, (GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glVertexAttrib4fv(int index, java.nio.FloatBuffer v)
 *     C function: void glVertexAttrib4fv(GLuint index, const GLfloat *  v)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glVertexAttrib4fv1__ILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint index, jobject v, jint v_byte_offset, jboolean v_is_nio) {
  GLfloat * _v_ptr = NULL;
  if ( NULL != v ) {
    _v_ptr = (GLfloat *) ( JNI_TRUE == v_is_nio ?  (*env)->GetDirectBufferAddress(env, v) :  (*env)->GetPrimitiveArrayCritical(env, v, NULL) );  }
  glVertexAttrib4fv((GLuint) index, (const GLfloat * ) (((char *) _v_ptr) + v_byte_offset));
  if ( JNI_FALSE == v_is_nio && NULL != v ) {
    (*env)->ReleasePrimitiveArrayCritical(env, v, _v_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glVertexAttribPointer(int index, int size, int type, byte normalized, int stride, java.nio.Buffer pointer)
 *     C function: void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *  pointer)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glVertexAttribPointer1__IIIBILjava_lang_Object_2IZ(JNIEnv *env, jclass _unused, jint index, jint size, jint type, jbyte normalized, jint stride, jobject pointer, jint pointer_byte_offset, jboolean pointer_is_nio) {
  void * _pointer_ptr = NULL;
  if ( NULL != pointer ) {
    _pointer_ptr = (void *) ( JNI_TRUE == pointer_is_nio ?  (*env)->GetDirectBufferAddress(env, pointer) :  (*env)->GetPrimitiveArrayCritical(env, pointer, NULL) );  }
  glVertexAttribPointer((GLuint) index, (GLint) size, (GLenum) type, (GLboolean) normalized, (GLsizei) stride, (const void * ) (((char *) _pointer_ptr) + pointer_byte_offset));
  if ( JNI_FALSE == pointer_is_nio && NULL != pointer ) {
    (*env)->ReleasePrimitiveArrayCritical(env, pointer, _pointer_ptr, JNI_ABORT);  }
}


/*   Java->C glue code:
 *   Java package: org.prismatic.kotlinangle.AngleNative
 *    Java method: void glViewport(int x, int y, int width, int height)
 *     C function: void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
 */
JNIEXPORT void JNICALL 
Java_org_prismatic_kotlinangle_AngleNative_glViewport__IIII(JNIEnv *env, jclass _unused, jint x, jint y, jint width, jint height) {
  glViewport((GLint) x, (GLint) y, (GLsizei) width, (GLsizei) height);
}


